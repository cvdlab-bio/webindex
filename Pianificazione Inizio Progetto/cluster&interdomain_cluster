
Cluster -> {
	"id": //text, key generated by the spatial partitioner to describe the spatial position of this cluster
	"type": "cluster"// value to differentiate between "cluster" and "inter_cluster" 
	"vertices": [
		[//0° coord, //1°coord, ... //n°coord]//0° vertex,
		[]//1° vertex
		[]//2° vertex
		.
		.
		[]//last vertex
	];
	"v_attributes":[
		[//0°attr, ..., //k°attr]//0° vertex's attribute - data source dependent - could be a color, density
		[]//1° vertex's attr
		.
		.
		[]//last vertex attr
	];//this is optional, but probably will be often present
	"cells": [
		[//vertex index, //vertex index, ... //last vertex index]//0° face, 
		[],
		[],
		.
		.
		[]//last face
	]; //max order cells. for a 3d model each face is composed of 4 veritices
	"adjacent_clusters": [//first cluster id, .., //last cluster id]	//how to define an adjacent cluster? simpler answer: an adjacent cluster share a cell with this cluster 
	"interdomain_clusters": [ //0° interdomain_cluster id, //1° interdomain_cluster id , .., //last interdomain cluster id] // this attribute exists to describe the cells that lie between two or more clusters
}

InterDomain_Cluster mod A-> {
	"id": //text, key generated by the spatial partitioner to describe the parents of this cluster
	"type": "inter_cluster"// "cluster" or "inter_cluster" - value to differentiate between schema
	"parent_clusters": [//first cluster id, .., //last cluster id];
	"vertices": [
		[//0° coord, //1°coord, ... //n°coord]//0° vertex,
		[]//1° vertex
		[]//2° vertex
		.
		.
		[]//last vertex
	];
	"v_attributes":[
		[//0°attr, ..., //k°attr]//0° vertex's attribute - data source dependent - could be a color, density
		[]//1° vertex's attr
		.
		.
		[]//last vertex attr
	];//this is optional, but probably will be often present
	"cells": [
		[//vertex index, //vertex index, ... //last vertex index]//0° face, 
		[],
		[],
		.
		.
		[]//last face
	]; //max order cells. for a 3d model each face is composed of 4 veritices

}