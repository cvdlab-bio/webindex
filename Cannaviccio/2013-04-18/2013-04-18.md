#Web Index
### Cluster Visualization
- - -
## Problem description
The aim of this task is to display large clusters of dots forming a "cancellous bone". 
The development of this application has been divided into two parts. The first concerns the back-end application, 
and includes the interface to the database (MongoDB) in which are stored all the clusters of points. 
MongoDb is the common point to all members of the group, through which each participant in the project can "communicate" with the rest of the team.

![ScreenShot](https://raw.github.com/cvdlab-bio/webindex/cannaviccio_dev_branch/immagini%20final-project/description.png)
The second part of the task has as its purpose the visualization of cluster via the web browser. In order to make the work more complete, 
statistics were done to compare the computational load that can withstand the technologies pyPlasm and plasmJs.
## Architecture
As described above the point of contact between members of the project is represented by the database. In order to make the project the most powerful, scalable, and efficient as possible we opted for an architecture based on NodeJs. This server uses an asynchronous event-driven, non-blocking I / O model that makes it lightweight and efficient, perfect for data-intensive real-time applications that run across distributed devices. 
To interface the server that runs the application services with MongoDb was used MongoJs interface. This module allows a fast and efficient use of the insert and retrieve functions on large amounts of data.
The exchange of messages between client and server has been run through the Socket.io module.Socket.io aims to make realtime apps possible in every browser and mobile device, blurring the differences between the different transport mechanisms.
To implement the visualization has been used mainly JavaScript language, using the development environment Plasm.js. In addition, tests were performed using the Python module PyPlasm.
![ScreenShot](https://raw.github.com/cvdlab-bio/webindex/cannaviccio_dev_branch/immagini%20final-project/architectureModel.png)

## Coordinates tranformation

###input
The cluster of points stored in the database is in JSON format. Each field of the JSON represents a characteristic of the cluster as for example the description and the point of the space in which it must be displayed to make the continuous succession of the cluster.
A small example of the format is shown below:
 
    { "_id" : "001", "dimension" : [ 200, 200, 256 ], "location" : [ 0, 0, 256 ], "points" : [ [ [ 180, 92 ], [ 181, 94 ], [ 183, 50 ] ] ] }

###From local to global
As you can see the JSON contains the field "points" which represent the position (in the form of x, y coordinates) of the point in space. These coordinates over that missing z coordinate are in the form of local coordinates to a single cluster. This "poor" representation is made by the partitioner to save space and computation time. To restore the correct viewing conditions is therefore necessary a transformation function. This function takes advantage of asynchronism of JavaScript to be efficient; the result of which is taken through a callback. In addition to the calculation of the global coordinates, the function also adds the z-coordinate at each point in the cluster, taking as a reference for the calculation the third value of the key "location" stored in JSON. Below is shown a significant excerpt of the function:

    for(var i = 0; i < points.length; i++)
      for(var j = 0; j < points[i].length; j++)
          var point = [ points[i][j][0] + xLoc, points[i][j][1] + yLoc, zLoc + i ];
          transPoints.push(point);
###Output
The function returns a JSON containing all the fields of the original one but with the values ​​of the key "location" changed. 
The example below shows the JSON after application of the transformation:

    { "_id" : "001", "dimension" : [ 200, 200, 256 ], "location" : [ 0, 0, 256 ], "points" : [ [ [ 180, 92, 256 ], [ 181, 94, 256 ], [ 183, 50, 257 ] ] ] }

          
## Visualization
The aim of this task is the development of the front-end of the project WebIndex and running tests on the partitioner.
The input of this phase is the JSON cluster from which they are extracted only the points that will be displayed and discard unnecessary information. The points extracted are then displayed on the web page test with Javascript (using Plasm.js) or with Python (using Pyplasm).

### Plasm.js
The points extracted from the cluster are displayed using the function POLYPOINT.
The clusters produced by the partitioner have different sizes (in numer of points), depending on the threshold used:
- 50K
- 100K
- 150K
- 200K
- 250K

Unfortunately, the display engine that provides the development environment Plasm.js has limits. After doing some experiments trying to use other functions or different approaches has been established viewing limit for Plasm.js. The display is permitted only with clusters of smaller size (50K points).
![ScreenShot](https://raw.github.com/cvdlab-bio/webindex/cannaviccio_dev_branch/immagini%20final-project/pyplasm.jpg)
#### Test page
The test page is a simple HTML page in which it was implemented a viewer Plasm.js. The user can choose the cluster of interest (using the ID) and wait for its display.
### PyPlasm
With python, using the library PyPlasm, the results are much better. Due to the increased power of the graphics engine and the different shape of the simplices used it was possible to see clusters of maximum size. Furthermore, two different approaches have been used for display. Besides the function POLYPOINT as occurred in Plasm.js, it was possible to display each point with a cube of unitary dimension making the display of the model more realistic.
![ScreenShot](https://raw.github.com/cvdlab-bio/webindex/cannaviccio_dev_branch/immagini%20final-project/python.jpg)
### Time computation
![ScreenShot](https://raw.github.com/cvdlab-bio/webindex/cannaviccio_dev_branch/immagini%20final-project/visualizators.jpg) 
![ScreenShot](https://raw.github.com/cvdlab-bio/webindex/cannaviccio_dev_branch/immagini%20final-project/confrontiModel.jpg)


